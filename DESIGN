# Changes in the template of genericworker.h that is generated by new robocompdsl

1. One of the first things that I noticed in the initial stages of development was that many features
   of the robocompdsl that it was supposed to do were not working. The .cdsl parser was broken. We
   couldn't specify which middleware to use in the component. It wasn't working for ICE. So fixed that.

2. The generated code for ROS1 was not even compiling, so I had to first fix ROS1 code generation and
   then move on to the ROS2.

3. For ROS2 one of the major challenges was to figure out how to compile it with cmake. Since ROS2 is
   different from ROS1 in a considerable way, and so was its build systemdemon slayer.

4. The second most important difference was the way in which ros msgs/srvs are built in both ROS
   versions. In ROS1 we have a script that can generate the necessary header files for msg files and
   srv files and then built those for the msg/srv headers to be included in the genericworker.h.
   While on the otherhand it is very complicated in ROS2 to directly generate the headers file because
   of the inherent design of the ROS2 which uses 3 different implementation DDS protocol. Something
   like this cant be handled by a single python script and so cmake MACROs are used instead.

5. Next problem was not with the ROS2 but with ROS1, the inconsistent design with different communi-
   cation modes (publishes, subscribesTo, implements, requires). For example: for 'publishes' mode in
   ROS1 there is a dedicated class of publishers with the name of interface specified, while for the
   'subscribesTo' mode in ROS2 there are callbacks written inside the GenericWorker class which makes
   it inconsistent. So what I have done is make a class for all the modes. A single class will handle
   all the things ROS. This class is instantiated in GenericWorker class and can be used through it.

