[
-- class name is choosen from the interface name
class Publisher/Subscriber/Server/Client{InterfaceName} {
]
public:
[   -- publishers are choosen on the basis of different types of data types
       present in the modules containing the interface, the dictionary data
       type is avoided as it is not available in ROS
    -- besides this topic interfaces according to ICE syntax are also declared
       as publishers
    // rclcpp::Publisher<{ComponentName}::msg::{MessageName}>::SharedPtr pub_{PublisherName};
]
[
    -- same heuristic as publishers are employed in subscribers too
    // rclcpp::Subscription<{ComponentName}::msg::{MessageName}>::SharedPtr sub_{SubscriberName};
]
[
    -- servers are declared by checking if the interface
       is not a topic interface and then take all the methods
       as services (is the method doesn't contain the dictionary
       data type), names are decided by the names of methods
    // rclcpp::Service<{ComponentName}::srv::{ServiceName}>::SharedPtr server_{ServerName};
]
[
    -- same heuristic is adopted as servers
    // rclcpp::Client<{ComponentName}::srv::{ServiceName}>::SharedPtr client_{ClientName};
]
[
    -- TO BE ADDED LATER --
    -- to store the data from the Subscriber callback
    // {ComponentName}::msg::{MessageName} {DataType}_msg;
]

    rclcpp::Node::SharedPtr node;

    Publisher/Subscriber/Server/Client{InterfaceName} () {
        node = rclcpp::Node::make_shared ("Node Name");
        // pub_{PublisherName} =
                node->create_publisher<{ComponentName}::msg::{MessageName}>("{TopicName}", 10);
        // sub_{SubscriberName} =
                node->create_subscription<{ComponentName}::msg::{MessageName}>("{TopicName}", 10,
                              std::bind(&Subscriber{InterfaceName}::cb_{SubscriberName}, this, _1));
        // server_{ServerName} =
                node->create_service<{ComponentName}::srv::{ServiceName}>("{TopicName}",
                                    std::bind(&Server{InterfaceName}::{ServerName}, this, _1, _2));
        // client_{ClientName} =
                            node->create_client<{ComponentName}::srv::{ServiceName}>("{TopicName}");
    }
    ~Publisher/Subscriber/Server/Client{InterfaceName} () {}

    // void {ServerName} (const std::shared_ptr<{ComponentName}::srv::{ServiceName}::Request> req,
                          std::shared_ptr<{ComponentName}::srv::{ServiceName}::Response> res) {}
    // void cb_{SubscriberName} (const {ComponentName}::msg::{MessageName}::SharedPtr msg) {}
};
